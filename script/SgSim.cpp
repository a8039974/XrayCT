// Sinogram simulation tools

#include "CmdTools.hpp"
#include "T2D.hpp"
#include <tclap/CmdLine.h>

int main(int argc, char **argv) {

  // Load configuration
  TCLAP::CmdLine cmd("2D C-ARM sinogram simulation.\n This program reads an acquisition configuration file (generated by Config2Txt), and also an image file of type supported by CImag library. The output is a directory\
 containning the sinogram and completed acquisition configuration.\n\
Examples:\n\
1. SgSim.run acq.cfg phantom.png -m pixdrv --phs 0 -v\n\
calculates the noiseless sinogram using GPU pixel-driven method on the image phantom.png with configuration file acq.cfg.\n\
2. SgSim.run acq.cfg phantom.png -m pixbi --snr 25 -v\n\
calculates the noisy sinogram using pixel bi-interpolation method on the image phantom.png with configuration file acq.cfg, a white noise is added to the clean sinogram such that the output sinogram has SNR about 25db.\n");

  TCLAP::UnlabeledValueArg<string> cfg_fnameArg("cfg_fname","Input configuration file name",true,"","string", cmd);
  TCLAP::UnlabeledValueArg<string> im_fnameArg("im_fname","Input phantom image file name",true,"","string", cmd);
  TCLAP::UnlabeledValueArg<string> outpath_fnameArg("outpath_fname","Output path name",false,"","string", cmd);

  TCLAP::ValueArg<size_t> phsArg("p", "phs", "Source intensity, 0 for noiseless sinogram. [1e7]", false, 10000000, "size_t", cmd);
  TCLAP::ValueArg<double> snrArg("s", "snr", "Desired SNR of sinogram. Gaussian noise model will be used if this value > 0. [0]", false, 0, "double", cmd);

  TCLAP::ValueArg<string> methodArg("m", "method", "Name of projection method : 'siddon', 'pixbi', 'pixdrv', 'blobdrv'. [pixdrv]", false, "pixdrv", "string", cmd);
  TCLAP::SwitchArg backprojSwitch("b", "backproj", "Display the back-projection. [false]", cmd, false);

  TCLAP::ValueArg<size_t> gpuidArg("g", "gpuid", "ID of gpu device to use. [0]", false, 0, "size_t", cmd);
  TCLAP::MultiSwitchArg verboseSwitch("v", "verbose", "Print informations and display image. [false]", cmd, false);

  cmd.parse(argc, argv);

  // Create output path
  string cfg_fname = cfg_fnameArg.getValue();
  SimConfig conf = CmdTools::load_acqcarm(cfg_fname.data());
  string im_fname = im_fnameArg.getValue();

  conf.phs = phsArg.getValue();  
  conf.method = methodArg.getValue();
  double snr = snrArg.getValue();
  bool backproj = backprojSwitch.getValue();
  int verbose = verboseSwitch.getValue();
  size_t gpuid = gpuidArg.getValue();

  // Load image  
  ImageXXd im = CmdTools::imread(im_fname);
  // Complet (or overwrite) acqconf
  conf.dimObj = Array2i(im.cols(), im.rows()); // image resolution
  conf.spObj = Acq::eval_splStep(conf.fanbeam, conf.rSrc[0], conf.rDet[0], conf.sizeDet, conf.dimObj); // Determine automatically the pixel size of image
  conf.sizeObj = Array2d(conf.dimObj.x() * conf.spObj, conf.dimObj.y() * conf.spObj);
  //cout<<conf<<endl;

  // Generating noisy sinogram
  ArrayXd Y(conf.nbProj_total * conf.pixDet); // Projection
  Y.setZero();

  ArrayXd U(conf.dimObj.prod()); // Backprojection
  U.setZero();

  if (conf.method == "siddon") {
    cout<<"Calculating sinogram with siddon ray-driven projector..."<<endl;

    clock_t t1 = clock();
    for (int p=0; p<conf.nbProj_total; p++)
      Siddon_OTF(conf.fanbeam, conf.rSrc[p], conf.pSrc[p], conf.rDet[p], 0, conf.spObj, 
		 conf.dimObj.y(), conf.dimObj.x(), conf.spDet, conf.pixDet, im.data(), Y.data()+p*conf.pixDet, 1);
    t1 = clock() - t1;    
    printf("Projection taken %lf seconds\n", t1/(double)CLOCKS_PER_SEC); 

    if (backproj) {
      clock_t t2 = clock();
      for (int p=0; p<conf.nbProj_total; p++)
	Siddon_OTF(conf.fanbeam, conf.rSrc[p], conf.pSrc[p], conf.rDet[p], 0, conf.spObj, 
		   conf.dimObj.y(), conf.dimObj.x(), conf.spDet, conf.pixDet, U.data(), Y.data()+p*conf.pixDet, 0);
      t2 = clock() - t2;    
      printf("Backprojection taken %lf seconds\n", t2/(double)CLOCKS_PER_SEC); 
    }      
  }
  // RegularSampling is disabled 'cause strange error occurs in the backprojection
  // else if (conf.method == "rglspl") {
  //   cout<<"Calculating sinogram with regular-sampling projector..."<<endl;
  //   for (int p=0; p<conf.nbProj_total; p++)
  //     RegularSampling_OTF(conf.fanbeam, conf.rSrc[p], conf.pSrc[p], conf.rDet[p], conf.rtDet[p], conf.spObj, 
  // 			  conf.dimObj.y(), conf.dimObj.x(), conf.spDet, conf.pixDet, im.data(), Y.data()+p*conf.pixDet, 1);
  //   if (backproj) {
  //     for (int p=0; p<conf.nbProj_total; p++)
  // 	RegularSampling_OTF(conf.fanbeam, conf.rSrc[p], conf.pSrc[p], conf.rDet[p], conf.rtDet[p], conf.spObj, 
  // 			    conf.dimObj.y(), conf.dimObj.x(), conf.spDet, conf.pixDet, U.data(), Y.data()+p*conf.pixDet, 0);
  //   }      
  // }
  else if (conf.method == "pixbi") {
    cout<<"Calculating sinogram with pixel-driven bi-interpolation projector..."<<endl;

    clock_t t1 = clock();
    for (int p=0; p<conf.nbProj_total; p++)    
      PixelDriven_OTF(conf.fanbeam, conf.rSrc[p], conf.pSrc[p], conf.rDet[p], 0, conf.spObj, 
    		      conf.dimObj.y(), conf.dimObj.x(), conf.spDet, conf.pixDet, im.data(), Y.data()+p*conf.pixDet, 1);
    t1 = clock() - t1;    
    printf("Projection taken %lf seconds\n", t1/(double)CLOCKS_PER_SEC); 

    if (backproj) {
      clock_t t2 = clock();
      for (int p=0; p<conf.nbProj_total; p++)
    	PixelDriven_OTF(conf.fanbeam, conf.rSrc[p], conf.pSrc[p], conf.rDet[p], 0, conf.spObj, 
    			conf.dimObj.y(), conf.dimObj.x(), conf.spDet, conf.pixDet, U.data(), Y.data()+p*conf.pixDet, 0);
      t2 = clock() - t2;    
      printf("Backprojection taken %lf seconds\n", t2/(double)CLOCKS_PER_SEC); 
    }
  }  
  else if (conf.method == "pixdrv") {
    cout<<"Calculating sinogram with GPU pix-driven projector..."<<endl;    
    cout<<"This method is just the siddon projector implemented on GPU in a pixel-driven manner, it calculates the intersection length between ray and pixel."<<endl;
    
    Tools::setActiveGPU(gpuid);	// Set GPU device
    
    PixDrvProjector P(conf, conf.dimObj, conf.spObj);

    ArrayXd X = Map<ArrayXd>(im.data(), im.size()); // flattened image vector

    clock_t t1 = clock();
    Y = P.forward(X);
    t1 = clock() - t1;
    printf("Projection taken %lf seconds\n", t1/(double)CLOCKS_PER_SEC); 

    if (backproj) {
      clock_t t2 = clock();
      U = P.backward(Y);
      t2 = clock() - t2;

      printf("Backprojection taken %lf seconds\n", t2/(double)CLOCKS_PER_SEC); 
    }
  }
  else if (conf.method == "blobdrv") {
    cout<<"Calculating sinogram with GPU blob-driven projector..."<<endl;

    // Set GPU device
    Tools::setActiveGPU(gpuid);

    // Init image model
    BlobImage *BI = BlobImageTools::SingleGaussPix(conf.dimObj, conf.spObj);
    //cout<<*BI<<endl;

    // Init GPU Blob projector
    BlobProjector P(conf, BI, 0);
    // if (verbose>1)
    //   cout<<P<<endl;

    ArrayXd X = Map<ArrayXd>(im.data(), im.size()); // flattened image vector
    if (verbose>1) {
      ImageXXd imb = BI->blob2pixel(X, conf.dimObj * 2); // blobimage interpolated from pixel value
      vector<ImageXXd> Dimr = BI->blob2pixelgrad(X, conf.dimObj * 2); // Its gradient
      CmdTools::imshow(imb, "Blob image");
      CmdTools::imshow(Dimr[0], "DX");
      CmdTools::imshow(Dimr[1], "DY");
    }

    clock_t t1 = clock();
    Y = P.forward(X);
    t1 = clock() - t1;
    printf("Projection taken %lf seconds\n", t1/(double)CLOCKS_PER_SEC); 

    if (backproj) {
      clock_t t2 = clock();
      U = P.backward(Y);
      t2 = clock() - t2;

      printf("Backprojection taken %lf seconds\n", t2/(double)CLOCKS_PER_SEC); 
    }
  }
  else {
    cout<<conf.method<<" : Unknown projection method."<<endl; 
    exit(1); 
  }

  ArrayXd Z;			// Noisy sinogram
  Array3d info(0,0,0); // Noisy sinogram information

  if (snr > 0) {
    Z = Tools::gaussian_data(Y, snr, info);
    cout<<"Gaussian noisy sinogram : "<<endl;
    cout<<"Noise energy : "<<info[0]<<endl;
    cout<<"Noise std : "<<info[1]<<endl;
    cout<<"SNR : "<<info[2]<<" db"<<endl;
  }
  else if (conf.phs > 0) {
    Z = Tools::poisson_data(Y, conf.phs, info);
    cout<<"Poisson noisy sinogram : "<<endl;
    cout<<"Noise energy : "<<info[0]<<endl;
    cout<<"Noise std : "<<info[1]<<endl;
    cout<<"SNR : "<<info[2]<<" db"<<endl;
  }
  else
    Z = Y;

  if (verbose) {
    CmdTools::imshow(im, "Phantom");
    CmdTools::imshow(Z.data(), conf.nbProj_total, conf.pixDet, "Sinogram");
    if (backproj) {
      CmdTools::imshow(U.data(), conf.dimObj.y(), conf.dimObj.x(), "Noiseless Backprojection");
    }
  }

  conf.phantom = im_fname; 
  conf.noise_energy = info[0];
  conf.noise_std = info[1];
  conf.snr = info[2];
  if (verbose)
    cout<<conf<<endl;

  string outpath_fname = outpath_fnameArg.getValue();
  if (outpath_fname=="") {
    char buffer[256];
    string fname = CmdTools::extractFilename(im_fname);
    //cout<<fname<<endl;
    if (snr>0)
      sprintf(buffer, "%s_nbProj%d_pixDet%d_%ddb", fname.c_str(), conf.nbProj_total, conf.pixDet, (int)snr);
    else
      sprintf(buffer, "%s_nbProj%d_pixDet%d_%ddb", fname.c_str(), conf.nbProj_total, conf.pixDet, (int)conf.snr);
    outpath_fname = buffer;
  }
  //cout<<outpath_fname<<endl;
  outpath_fname = CmdTools::creat_outpath(outpath_fname);

  // save sinogram data, configuration into output directory
  CmdTools::save_acqcarm(conf, outpath_fname+"/acq.cfg");
  CmdTools::savearray(Z, outpath_fname+"/sino");
  CmdTools::imsave(Z,  conf.nbProj_total, conf.pixDet, outpath_fname+"/sino");
  cout<<"Outputs saved in directory "<<outpath_fname<<endl;

  return 0;
}

